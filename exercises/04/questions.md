# TIE-50307 - Exercise 04 - Q&A

## 1. What is the goal of this exercise? What did you accomplish?
- Implement interrupt handler for interrupts generated by a custom IRQ_generator
- Leared about IRQ handling under linux
- Learned about memory addresses and remaping from physical address of an I/O device to the kernel virtual address usin ioremap
- Learned how to use linux/bitfield.h macros to manipulate registers with ioread32 and iowrite32 functions

## 2. Summarize the functionality provided by the IRQ Generator IP block, then describe what is the purpose of the various registers exposed by the FPGA device. Finally, ignore the fact that you were instructed to look for the base address of the IRQ Generator register space in the provided `devicetree.dts` and instead imagine you were also the developer of the FPGA core design, where would you have found the base address of the register space?
- The irq generator block allows for level-sensitive interrupt generation between the PL(Programmable logic, FPGA) and PS (processing system). The PL is connected to the interrupt input lines on the PS which is running the linux OS. 
- The IP block is controlled by writing to the appropriate registers using the genirq-ex4 kernel module
- IRQ's recieved by the PS are handled on interupt line assertion when handled are ACK'd. Based on the number of clock edges between assertion and ACK, the interupt latency of the PS can be calculated\
- The IP block exposes 4, 32-bit registers:
    - IRQ_GEN_CTRL_REG - Controls functionality of IP Block. Enable block, IRQ handled bit and acknowledgement of the respective IRQ line that has been asserted
    - IRQ_GEN_GENIRQ_Reg - Used to set desired IRQ generation parameters such as which line to use, delay between IRQ's generated and the number of IRQ's to generate
    - IRQ_GEN_IRQ_COUNT_REG - read only register containing count of IRQ's generated
    - IRQ_GEN_LATENCY_REG - Contains latency of last sucessfully handled IRQ.  Latency is calculated by counting the number of positive clock edges between interrupt line assertion and IRQ handling(handled and ACK) 
- Base address:
    - The base would need to be found by carefully reviewing the SOC documentation

## 3. Describe the relationship between interrupt lines in the IRQ Generator, HW IRQ and Linux IRQ numbers, and how did you proceed to discover the IRQ number to use in the driver.
- The interrupt lines of the IRQ Generator IRQF2P[15:0] are mapped to IRQ IDs 61-68 and 84-91(HW IRQ numbers)
- Linux provides a mapping layer between the Hardware IRQ and the Linux Kernel IRQ number
- The Linux kernel exposes the mappings between HWIRQ, LINUX IRQ and associated device through the sysfs pseudo filesystem located in the folder /sys/kernel/irq
- This directory contains a folder for each LINUXIRQ number avalible
- Each of these folders contain pseudofiles information including the "hwirq" value
- grep -s <HWIRQ> */hwirq extracts this number.
    - in our case HWIRQ 61 is mapped to LINUXIRQ 45

## 4. How many interrupt lines are available in the documented FPGA core (refer to the spec, even if we only used one in the *beta* bitstream we were given)?
- 16 interrupt lines [0-15] are available

## 5. What value is reported in the devicetree for the first IRQ line? How is it determined? (check the spec document, it has all the required information to map the line number to the HW IRQ on the processing system)
- interrupts = <0x0 0x1d 0x4>;
- 3 cells used to specify the interupt.  
    - 0x0: interrupt type = Shared peripheral interrupt
    - 0x1d: interrupt Number
    - 0x4: interrupt signal type = Active high level-sensitive

## 6. Using the information detailed in the previous answer, what should be written in the `devicetree.dts` line describing the IRQ Generator interrupts if it were to describe all the 16 HW IRQs? (write the exact line as it would appear in the `devicetree.dts`, notice that the HW IRQs are not contiguous!). Each interrupt line is specified by three cells in the device tree file; what information does each of these three cells represent?
- for all 16:\
<0x0 0x1d 0x4 0x0 0x1e 0x4 0x0 0x1f 0x4 0x0 0x20 0x4\
<0x0 0x21 0x4 0x0 0x22 0x4 0x0 0x23 0x4 0x0 0x24 0x4\
<0x0 0x34 0x4 0x0 0x35 0x4 0x0 0x36 0x4 0x0 0x37 0x4\
<0x0 0x38 0x4 0x0 0x39 0x4 0x0 0x3a 0x4 0x0 0x3b 0x4>
- 3 cells each
    - Cell 1 = interrupt type (0x0 = Shared peripheral interrupt)
    - Cell 2 = interrupt number (not continous)
    - Cell 3 - interrupt signal type (0x4 = Active high level-sensitive)

## 7. Why do we need to use `ioremap`, `ioread32` and `iowrite32`? Why do we want to use the Linux kernel bitfields macroes rather than using bitwise arithmetic directly?
- ioremap: I/O memory regions must be allocated prior to use and must be made avalible to the kernel. Depending on architecture it is nessesary to assign virtual addresses to I/O memory regions. This is what ioremap is used for.
- ioread32 and iowrite32 are required to work with I/O memory in a platform portable way
- bitfield macros simply the task of performing the required bitwise arithmetic in a platform independent way (big endian/little endian etc).   
## 8. (BONUS, optional) Did you find any bug in the bitstream implementation while testing the sysfs interface?

## 9. Feedback (what was difficult? what was easy? how would you improve it?)
- Not to difficult,  could not find much documentation on use of bitfield.h macros
